<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>step02_xhr.html</title>
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
</head>
<body>
    <script>
        // JSON : JavaScript Object Notation
        // 데이터를 문자열의 형태로 주고 받도록 만들어진 내장 객체

        // const students = {
        //     name: 'it',
        //     age: 30,
        //     courses: ['Linux', 'HTML/CSS', 'js']
        // }
        // console.log(students);

        // 1. 프론트 -> 서버로 데이터를 전송할 때
        // 2. 서버 -> 프론트로 데이터를 전송할 때
        // ? : 문자열로 전송하는 것이 메모리적으로도 효율
        // stringify : js 객체를 문자열로 변경
        // let jsonStudent = JSON.stringify(students);
        // console.log(jsonStudent);
        
        // 1. 프론트 / 서버가 받은 데이터를 자신의 객체로 바꾸어서 사용
        // parse : 문자열을 js 객체로 변경
        // let newStudent = JSON.parse(jsonStudent);
        // console.log(newStudent);

        // json을 사용할 때 key도 문자열로 변경해야 한다.
        // json을 사용할 때에는 반드시 "" 사용해야함
        let obj1 = {key1: "v1"};
        let obj2 = "{'key2': 'v2'}";
        let obj3 = '{"key3": "v3"}';
        // console.log((obj1).key1);


        // console.log(JSON.parse(obj2).key2);
        // console.log(JSON.parse(obj3).key3);

        // XMLHttpRequest
        // function ajaxTest() {

        //     var xhr = new XMLHttpRequest();

            // onreadystatechage
            // client 와 server 간에 통신을 할 때
            // 중간 단계에 대한 변화를 감지하여 자동으로 실행되는 로직

            // readystate 숫자로 표현
            // 1 : 요청 시작
            // 2 : 요청 중
            // 3 : 응답 중
            // 4 : 응답 완료

            // status 200 정상 응답
        //     xhr.onreadystatechange = function() {
        //         // alert(this.readyState)
        //         if(this.readyState == 4 && this.status == 200) {
        //             // console.log((JSON.parse(this.responseText)[3]).phone);
        //             // console.log(this);
        //         }

        //     }

        //     // 실제 요청(방식, 요청주소, 비동기요청(true))
        //     xhr.open("GET", "https://jsonplaceholder.typicode.com/users", true);
        //     xhr.send();
        // }
        // ajaxTest();

        // fetch
        // fetch("https://jsonplaceholder.typicode.com/users") // promise 객체 반환
        //     .then((response)=> response.json())
        //     .then((users) => {console.log(users)})

        // fetch 실제 사용
        // .으로 연결하는 것을 메소드 체이닝이라고 함
        // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch
        // fetch("https://jsonplaceholder.typicode.com/posts/1")
        //     .then(response => response.json())
        //     .then(post => post.userId)
        //     .then(userId => "https://jsonplaceholder.typicode.com/users/" + userId)
        //     .then(url => fetch(url))
        //     .then(response => response.json())
        //     .then(user => console.log(user))
        //     .catch((err) => {})

        // 메소드의 종류와 활용방법
        // 1. GET : 클라이언트가 서버에 특정 데이터를 요청할 때 사용하는 메소드
        // fetch의 기본 요청방식은 GET, 따라서 따로 지정할 필요가 없음

        // 2. POST : 클라이언트가 서버에 특정 데이터를 생성할 때 사용하는 메소드
        // fetch("https://jsonplaceholder.typicode.com/posts/1", {
        //     method: "PUT",
        //     headers: {
        //         "Content-Type": "application/json"
        //     },
        //     body: JSON.stringify({
        //         usrId: 1,
        //         title: "post testing",
        //         body: "post testing!"

        //     })
        // })
        // .then((response) => response.json())
        // .then(data => console.log(data))
        
        // 3. PUT : 클라이언트가 서버에 특정 데이터의 정보를 수정할 때 사용하는 메소드
        
        // 4.DELETE : 클라이언트가 서버에 특정 데이터를 삭제할 때 사용하는 메소드
        
        // fetch("https://jsonplaceholder.typicode.com/posts/1", {
        //     method: "DELETE",
        // })
        // .then((response) => response.json())
        // .then(data => console.log(data))
        
        // https://axios-http.com/kr/docs/intro
        // axios : 비동기 통신을 위한 프로미스 기반의 라이브러리
        // 라이브러리 vs 프레임워크 : 면접 때 나올 수 있는 개념
        // const newObj = {
        //     userId :1,
        //     title: "post",
        //     body: "post"
        // }
        
        let url = "https://jsonplaceholder.typicode.com/posts"

        // axios.get(url, newObj)
        //     .then((response) => console.log(response))
            // .then((data) => data[3])
            // .then()
        // // fetch : post, put, delete --> axios : post, put, delete
        // axios.post(url, newObj)
        //    .then((response) => console.log(response))

        // axios.put(`${url}/1`, {
        //     title: "js",
        //     body: "js" 
        // }).then((response) => console.log(response.data))

        // axios.delete(`${url}/1`)
        //     .then((response) => console.log(response.data));
        
        
        // 객체(확장 사용)
        const bret ={
            "id": 1,
            "name": "Leanne Graham",
            "username": "Bret",
            "email": "Sincere@april.biz",
            "address": {
                "street": "Kulas Light",
                "suite": "Apt. 556",
                "city": "Gwenborough",
                "zipcode": "92998-3874",
                "geo": {
                    "lat": "-37.3159",
                    "lng": "81.1496"
                }
            },
            "phone": "1-770-736-8031 x56442",
            "website": "hildegard.org",
            "company": {
                "name": "Romaguera-Crona",
                "catchPhrase": "Multi-layered client-server neural-net",
                "bs": "harness real-time e-markets"
            }
        }

        // lat, lng ?? <-- 비구조화 할당 문법을 이용하여 데이터 추렭하기

        const {lat, lng} = bret.address.geo;
        // console.log(lat)
        // console.log(lng)

        // console.log(bret.address.zipcode)
        let bretZipcode = bret.address.zipcode;
        // console.log(bretZipcode)

        // 객체 비구조화 할당
        // const obj = {
        //     a: 1,
        //     b: 2,
        //     name: "it"
        // }

        // console.log(obj.b);

        // const {a, b, name, c = 0} = obj;

        // name = "it2";

        // console.log(obj.name)

        const arr = [1, 2];
        
        const [one, two] = arr;
        console.log(one);
        console.log(two);

        const objArr = {
            info: {
                private: {
                    name: 'js',
                    age: 24,
                    hobbies: ['programing, algorithm']
                }
            },
            purpose: 'destructure test'
        }
        const { name, age, hobbies } = objArr.info.private;
        console.log(name);

        const newObj = {
            name,
            age,
            hobbies
        }

        // console.log(newObj);

        // rest(...)
        const avengers = ['토르', '스파이더맨', '닥터'];
        const totalAvengers = [...avengers, '미스제인']; // 구조 분해 후 요소 추가

        console.log(avengers, totalAvengers);

        // 객체
        // 한국과 관련된 정보를 담고 있는 객체
        // 대륙
        const planet = {
            continent: 'Asia'
        };

        const country = {
            // continent: 'Asia'
            ...planet,
            countryName: 'ROK'
        }

        const city = {
            // continent: 'Asia',
            // countryName: 'ROK',
            ...country,
            region: 'Busan'
        }

        console.log(planet);
        console.log(country);
        console.log(city);

        // 함수
        // function sum(x, y) {
        //     return x + y + z;
        // }

        function sum(...rest) {
            // console.log(rest);
            return rest.reduce((accumulator, currentValue) =>(accumulator + currentValue));
        }
        sum(1, 2, 3);
        console.log(sum(1, 2, 3, 5, 24, 5, 1, 56, 657));
        
        // 실제 넘겨져 온 데이터를 활용하는 방법
        // https://dog.ceo/dog-api/


















        // HTTP 메세지 구조
	    // 1) Start Line
        // HTTP 메소드, Request target, HTTP version
		
        // HTTP 메소드 : GET, POST, PUT, DELETE
      
				// Request target : HTTP Request가 전송되는 목표 주소
        // HTTP version "  Request 메시지 구조나 데이터가 다를 수 있어서 version 명시

        // 2) Header
        // Date : 현재시간
        // Cache-Control : 캐시 제어
        // Transfer-Encoding : Body 내용 자체 압축 방식
        // Content-Encoding : Body의 리소스 압축 방식
        // Content-type : Body의 미디어 타입 ex) application/json, text/html
        // Content-Length : Body의 길이
        // Content-language : Body를 이해하는데 가장 적절한 언어 ex) ko
        // Connection : 클라이언트와 서버의 연결 방식

        // Server : 웹 서버의 종류
        // Age : max-age 시간내에서 얼마나 흘렀는지 초 단위로 알려주는 값
        // Referrer-policy : 서버 referrer 정책을 알려주는 값 ex) origin, no-referrer, unsafe-url
        // WWW-Authenticate : 사용자 인증이 필요한 자원을 요구할 시, 서버가 제공하는 인증 방식
        // Proxy-Authenticate : 요청한 서버가 프록시 서버인 경우 유저 인증을 위한 값
	
	    // Host : 요청하려는 서버 호스트 이름과 포트번호
        // User-agent : 클라이언트 프로그램 정보
        // Referer : 바로 직전에 머물렀던 웹 링크 주소 
        // Accept : 클라이언트가 처리 가능한 미디어 타입 종류 나열
        // If-Modified-Since : 여기에 쓰여진 시간 이후로 변경된 리소스 취득
        // Authorization : 인증 토큰을 서버로 보낼 때 쓰이는 Header
        // Origin : 서버로 Post 요청을 보낼 때 요청이 어느 주소에 시작되었는지 나타내는 값



    </script>
</body>
</html>